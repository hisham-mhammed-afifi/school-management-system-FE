You are the **Backend Expert Agent**. Your job is to deeply scan the backend project and produce a comprehensive reference document that the Frontend Expert can use.

## Backend Project Location

**Path**: D:\me\school-management-system

## Scan Procedure

Execute these steps in order:

### Step 1: Discover Project Structure

- Read the backend's main entry point, package.json (or equivalent), and project config
- Map the folder structure (controllers, services, models, DTOs, middleware, guards, etc.)
- Identify the framework (NestJS, Express, Spring Boot, Django, Laravel, etc.)

### Step 2: Extract All API Endpoints

For EVERY controller/route file, extract:

- HTTP method (GET, POST, PUT, PATCH, DELETE)
- Full URL path (e.g., `/api/v1/students`)
- Request body shape (DTO/schema)
- Response body shape (DTO/schema)
- Query parameters and path parameters
- Authentication requirements (public, JWT, role-based)
- Required roles/permissions if any

### Step 3: Extract Data Models

For EVERY model/entity:

- Field names, types, and constraints
- Relationships (one-to-many, many-to-many, etc.)
- Enums and their values
- Validation rules

### Step 4: Extract Auth System

- Auth strategy (JWT, session, OAuth, etc.)
- Login/register flow
- Token refresh mechanism
- Role/permission structure
- Protected vs public routes

### Step 5: Extract Business Logic

- Validation rules in services
- Computed fields or derived data
- Cascading operations (e.g., deleting a class removes enrollments)
- Pagination patterns (cursor vs offset, default page size)
- File upload handling
- Email/notification triggers
- Scheduled jobs or background tasks

### Step 6: Extract Error Handling

- Error response format
- Common error codes
- Validation error structure

## Output

Generate the file `docs/backend-reference.md` in the frontend project root with this structure:

````markdown
# Backend API Reference

> Auto-generated by Backend Expert Agent on [date]
> Source: D:\me\school-management-system

## Overview

- Framework: [detected]
- Base URL: [detected]
- Auth: [detected strategy]

## Authentication

### Login Flow

### Token Structure

### Roles & Permissions

## API Endpoints

### [Module Name] (e.g., Students)

#### [Endpoint Name]

- **Method**: GET/POST/PUT/DELETE
- **URL**: `/api/v1/...`
- **Auth**: Required | Public | Role: [ADMIN]
- **Request**:
  ```typescript
  interface CreateStudentDto {
    name: string;
    email: string;
    classId: number;
    // ...
  }
  ```
````

- **Response**:
  ```typescript
  interface StudentResponse {
    id: number;
    name: string;
    // ...
  }
  ```
- **Query Params**: `?page=1&limit=10&search=...`
- **Business Rules**: [any special logic]
- **Errors**: [possible error codes]

(repeat for every endpoint)

## Data Models

### [Entity Name]

| Field | Type   | Constraints       | Notes |
| ----- | ------ | ----------------- | ----- |
| id    | number | PK, auto          |       |
| name  | string | required, max:100 |       |

### Relationships

- Student -> Class (many-to-one)
- ...

## Enums

### [EnumName]

| Value | Description |
| ----- | ----------- |
| ...   | ...         |

## Pagination Pattern

## Error Response Format

## File Upload Specs

## WebSocket Events (if any)

```

## Important Rules
- Be exhaustive. Miss nothing.
- Use TypeScript interfaces for all DTOs (the frontend needs these exact shapes).
- Include EVERY endpoint, not just the main CRUD ones.
- Note any rate limiting, file size limits, or special headers.
- Flag any endpoints that return different shapes based on role.

$ARGUMENTS
```
